// Generated by CoffeeScript 1.3.1
(function() {
  var NoteRain,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  NoteRain = (function() {

    NoteRain.name = 'NoteRain';

    NoteRain.prototype.noteScale = 0.001;

    function NoteRain(pianoDesign) {
      this.pianoDesign = pianoDesign;
      this.update = __bind(this.update, this);

      this.model = new THREE.Object3D();
      this.noteToColor = (function() {
        var map;
        map = MusicTheory.Synesthesia.map('August Aeppli (1940)');
        return function(note) {
          return parseInt(map[note - MIDI.pianoKeyOffset].hex, 16);
        };
      })();
    }

    NoteRain.prototype.setMidiData = function(midiData) {
      var Black, KeyType, blackKeyHeight, blackKeyWidth, color, currentTime, duration, event, geometry, interval, keyInfo, length, material, mesh, noteNumber, notes, startTime, subtype, x, y, z, _i, _len, _ref, _ref1, _ref2, _results;
      _ref = this.pianoDesign, blackKeyWidth = _ref.blackKeyWidth, blackKeyHeight = _ref.blackKeyHeight, keyInfo = _ref.keyInfo, KeyType = _ref.KeyType;
      Black = KeyType.Black;
      notes = [];
      currentTime = 0;
      _results = [];
      for (_i = 0, _len = midiData.length; _i < _len; _i++) {
        _ref1 = midiData[_i], (_ref2 = _ref1[0], event = _ref2.event), interval = _ref1[1];
        currentTime += interval;
        subtype = event.subtype, noteNumber = event.noteNumber;
        if (subtype === 'noteOn') {
          _results.push(notes[noteNumber] = currentTime);
        } else if (subtype === 'noteOff') {
          startTime = notes[noteNumber];
          duration = currentTime - startTime;
          length = duration * this.noteScale;
          x = keyInfo[noteNumber].keyCenterPosX;
          y = startTime * this.noteScale + (length / 2);
          z = -0.2;
          if (keyInfo[noteNumber].keyType === Black) {
            y += blackKeyHeight / 2;
          }
          color = this.noteToColor(noteNumber);
          geometry = new THREE.CubeGeometry(blackKeyWidth, length, blackKeyWidth);
          material = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            opacity: 0.7,
            transparent: true
          });
          mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(x, y, z);
          _results.push(this.model.add(mesh));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    NoteRain.prototype.update = function(playerCurrentTime) {
      return this.model.position.y = -playerCurrentTime * this.noteScale;
    };

    return NoteRain;

  })();

  this.NoteRain = NoteRain;

}).call(this);
